<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>webpng — PNG ↔ WebP Converter</title>
  <style>
    :root {
      --bg: #0f1115; --panel: #12151b; --muted: #7a8699; --text: #e9eef5;
      --accent: #ff4f9a; --border: #1f2430; --ok: #2ecc71; --warn: #f39c12; --bad: #e74c3c;
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji", "Segoe UI Emoji";
           background: radial-gradient(1200px 800px at 20% -10%, #1a2030 0, transparent 60%), var(--bg); color: var(--text); }
    .wrap { max-width: 1100px; margin: 40px auto; padding: 0 16px; }
    h1 { font-size: 28px; margin: 0 0 8px; text-align: center; }
    .sub { color: var(--muted); text-align: center; margin-bottom: 24px; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 16px; }
    @media (min-width: 900px) { .grid { grid-template-columns: 1fr 1fr; } }

    .panel { background: linear-gradient(180deg, #141925, #10131b); border: 1px solid var(--border);
             border-radius: 16px; padding: 16px; box-shadow: 0 8px 24px rgba(0,0,0,.35); }
    .panel h2 { margin: 0 0 12px; font-size: 16px; letter-spacing: .2px; }

    .drop { border: 1.5px dashed #2a2f3c; border-radius: 16px; padding: 18px; text-align: center; background: #0e1219; }
    .drop.is-drag { outline: 2px solid var(--accent); outline-offset: 2px; }
    .muted { color: var(--muted); font-size: 13px; }
    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .row > * { margin: 0; }
    .btn { appearance: none; border: 1px solid var(--border); background: #171b24; color: var(--text);
           padding: 8px 12px; border-radius: 10px; cursor: pointer; font-weight: 600; }
    .btn:hover { background: #1a2030; }
    .btn.primary { background: var(--accent); border-color: #ff2f8a; color: #fff; }
    .btn.primary:hover { filter: brightness(1.05); }
    .btn.ghost { background: #121720; }
    .btn:disabled { opacity: .55; cursor: not-allowed; }

    .toggle { display: inline-flex; background: #141926; border: 1px solid var(--border); border-radius: 12px; overflow: hidden; }
    .toggle button { border: none; background: transparent; color: var(--text); padding: 8px 12px; cursor: pointer; }
    .toggle button.active { background: var(--accent); color: #fff; }

    .input { width: 100%; background: #121722; border: 1px solid var(--border); color: var(--text);
             padding: 8px 10px; border-radius: 10px; }
    .kv { display: grid; grid-template-columns: 1fr auto; gap: 8px; margin: 10px 0; font-size: 13px; }
    .kv span:last-child { color: #c7cfdb; }

    .canvasWrap { background: #0a0d14; border: 1px solid var(--border); border-radius: 12px; overflow: auto; min-height: 240px;
                  display: grid; place-items: center; }
    canvas { display: block; max-width: 100%; height: auto; }

    .note { font-size: 12px; color: var(--muted); margin-top: 8px; }
    .ok { color: var(--ok); } .warn { color: var(--warn); } .bad { color: var(--bad); }
    .err { margin-top: 8px; color: var(--bad); font-weight: 600; }
    .sp { height: 8px; }
    .range { width: 100%; }
    footer { margin-top: 18px; text-align: center; color: var(--muted); font-size: 12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>webpng — ultra-simple PNG ↔ WebP</h1>
    <div class="sub">Drop a PNG/JPG/WebP → pick output → download. All local, transparency preserved.</div>

    <div class="panel drop" id="drop">
      <div class="row" style="justify-content:center; gap:12px;">
        <label class="btn ghost">
          Choose file
          <input id="fileInput" type="file" accept="image/*" style="display:none" />
        </label>
        <div class="muted">…or drop an image here</div>
      </div>
      <div id="fileInfo" class="muted" style="margin-top:10px;"></div>
      <div id="error" class="err" role="alert" style="display:none;"></div>
    </div>

    <div class="sp"></div>

    <div class="grid">
      <div class="panel">
        <h2>Preview</h2>
        <div class="canvasWrap">
          <canvas id="canvas"></canvas>
        </div>
        <div class="kv">
          <span>Dimensions</span><span id="dims">—</span>
          <span>Original size</span><span id="origSize">—</span>
          <span>Output size</span><span id="outSize">—</span>
        </div>
      </div>

      <div class="panel">
        <h2>Output</h2>

        <div class="row" style="gap:8px; margin-bottom:10px;">
          <div class="toggle" role="tablist" aria-label="Output format">
            <button id="fmtWebp" class="active" aria-selected="true">WEBP</button>
            <button id="fmtPng" aria-selected="false">PNG</button>
          </div>
          <button id="convertBtn" class="btn primary" disabled>Convert</button>
          <a id="downloadLink" class="btn" download style="display:none;">Download</a>
        </div>

        <label class="muted" for="outName">Output name</label>
        <input id="outName" class="input" placeholder="image-name" />

        <div id="qualityWrap" style="margin-top:12px;">
          <div class="row" style="justify-content:space-between;">
            <label for="quality">Quality (WEBP)</label>
            <span id="qualityLabel" class="muted">92%</span>
          </div>
          <input id="quality" class="range" type="range" min="0.1" max="1" step="0.01" value="0.92" />
          <div class="note">(Higher quality = larger file)</div>
        </div>

        <div class="note">All processing happens in your browser. Nothing is uploaded.</div>
      </div>
    </div>

    <footer>Tip: drag a huge PNG and try WebP ~80–90% — you’ll often cut size dramatically with transparent pixels intact.</footer>
  </div>

  <script>
    (function () {
      const fileInput = document.getElementById('fileInput');
      const drop = document.getElementById('drop');
      const fileInfo = document.getElementById('fileInfo');
      const errEl = document.getElementById('error');
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d', { willReadFrequently: false });

      const fmtWebp = document.getElementById('fmtWebp');
      const fmtPng  = document.getElementById('fmtPng');
      const convertBtn = document.getElementById('convertBtn');
      const downloadLink = document.getElementById('downloadLink');

      const outName = document.getElementById('outName');
      const qualityWrap = document.getElementById('qualityWrap');
      const quality = document.getElementById('quality');
      const qualityLabel = document.getElementById('qualityLabel');

      const dims = document.getElementById('dims');
      const origSize = document.getElementById('origSize');
      const outSize = document.getElementById('outSize');

      let currentFile = null;
      let currentImgURL = '';
      let outputURL = '';
      let format = 'webp';

      const revoke = (url) => { if (url) URL.revokeObjectURL(url); };

      function bytes(n) {
        if (!Number.isFinite(n)) return '—';
        const k = 1024;
        if (n < k) return n + ' B';
        const units = ['KB', 'MB', 'GB'];
        let i = -1;
        do { n /= k; ++i; } while (n >= k && i < units.length - 1);
        return n.toFixed(1) + ' ' + units[i];
      }

      function setError(msg) {
        errEl.style.display = msg ? 'block' : 'none';
        errEl.textContent = msg || '';
      }

      function setFormat(next) {
        format = next;
        fmtWebp.classList.toggle('active', next === 'webp');
        fmtPng.classList.toggle('active', next === 'png');
        fmtWebp.setAttribute('aria-selected', next === 'webp');
        fmtPng.setAttribute('aria-selected', next === 'png');
        qualityWrap.style.display = next === 'webp' ? 'block' : 'none';
      }

      function clearOutput() {
        if (outputURL) { revoke(outputURL); outputURL = ''; }
        downloadLink.style.display = 'none';
        downloadLink.removeAttribute('href');
        outSize.textContent = '—';
      }

      function loadFile(f) {
        setError('');
        clearOutput();
        currentFile = f;
        fileInfo.textContent = f ? `Loaded: ${f.name}` : '';
        origSize.textContent = f ? bytes(f.size) : '—';

        if (!f) { return; }

        // derive default name
        const base = (f.name || 'image').replace(/\.[^/.]+$/, '');
        outName.value = base;

        // revoke prior img URL
        if (currentImgURL) { revoke(currentImgURL); currentImgURL = ''; }

        // draw into canvas
        const url = URL.createObjectURL(f);
        currentImgURL = url;
        const img = new Image();
        img.onload = () => {
          canvas.width = img.naturalWidth;
          canvas.height = img.naturalHeight;
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0);
          dims.textContent = `${img.naturalWidth} × ${img.naturalHeight}`;
          convertBtn.disabled = false;
        };
        img.onerror = () => setError('Failed to load that image.');
        img.src = url;
      }

      function handleFiles(fileList) {
        const f = fileList && fileList[0];
        if (!f) return;
        const ext = ((f.name.split('.').pop() || '').toLowerCase());
        const ok = ['png', 'jpg', 'jpeg', 'webp', 'gif'].includes(ext);
        if (!ok) { setError('Unsupported type. Try PNG/JPG/WEBP/GIF.'); return; }
        loadFile(f);
      }

      // Drag & drop
      ['dragenter', 'dragover'].forEach(t => drop.addEventListener(t, e => {
        e.preventDefault(); e.stopPropagation(); drop.classList.add('is-drag');
      }));
      ;['dragleave', 'drop'].forEach(t => drop.addEventListener(t, e => {
        e.preventDefault(); e.stopPropagation(); drop.classList.remove('is-drag');
      }));
      drop.addEventListener('drop', (e) => handleFiles(e.dataTransfer.files));

      // File input
      fileInput.addEventListener('change', (e) => handleFiles(e.target.files));

      // Format toggle
      fmtWebp.addEventListener('click', () => setFormat('webp'));
      fmtPng.addEventListener('click', () => setFormat('png'));

      // Quality slider
      quality.addEventListener('input', () => {
        qualityLabel.textContent = Math.round(parseFloat(quality.value) * 100) + '%';
      });

      // Convert
      convertBtn.addEventListener('click', async () => {
        if (!currentFile) return;
        setError('');
        clearOutput();

        const mime = format === 'png' ? 'image/png' : 'image/webp';
        const q = format === 'webp' ? parseFloat(quality.value) : undefined;

        try {
          const blob = await new Promise((resolve, reject) => {
            canvas.toBlob((b) => b ? resolve(b) : reject(new Error('Canvas export failed.')), mime, q);
          });
          outSize.textContent = bytes(blob.size);

          outputURL = URL.createObjectURL(blob);
          const name = (outName.value || 'image') + (format === 'png' ? '.png' : '.webp');
          downloadLink.href = outputURL;
          downloadLink.download = name;
          downloadLink.textContent = 'Download ' + name;
          downloadLink.style.display = 'inline-block';
        } catch (e) {
          console.error(e);
          setError('Conversion failed. Try a different image.');
        }
      });

      // Defaults
      setFormat('webp');
      convertBtn.disabled = true;

      // Cleanup on unload
      window.addEventListener('beforeunload', () => {
        revoke(currentImgURL); revoke(outputURL);
      });
    })();
  </script>
</body>
</html>
